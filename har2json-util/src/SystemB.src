import { BrowserUI } from "./BrowserUI.src";
import { FileCache } from "./FileCache.src";
import { FileUtils } from "./FileUtils.src";
import { SystemA } from "./SystemA.src";
import { WebkitFileIngester } from "./WebkitFileIngester.src";
import { credits } from "./credits.src";

export
class SystemB extends SystemA {
  constructor() {
    super();

    if (typeof(window) == "undefined") {
      throw new SystemA.ShuntingError("Not a browser environment");
    }

    this._document = window.document;

    this._arg = null;
    this._directoryInput = null;
    this._fileSource = null;
    this._fileName = null;
    this._ui = null;

    this._artifacts = new FileCache();
  }

  setUpForExec($$util) {
    return new Promise((resolve) => {
      this._document.defaultView.onload = (() => {
        this._ui = new BrowserUI(this, this._document);

        /*
        this.output = new ConsoleOutput({
          printLine: ((text) => void(this._ui.printFeedback(text)))
        });
        */

        let $$ = this._document.createElement.bind(this._document);

        let fileInput = $$("input");
        fileInput.setAttribute("type", "file");
        fileInput.style.display = "none";
        this._directoryInput = this._document.head.appendChild(fileInput);

        let app = new $$util(this);
        this._directoryInput.onchange = this._onDirectoryChange.bind(
          this, resolve, app
        );
        // TODO for good measure (incl. debugging purposes), we should
        // probably make the app instance globally accessible via UUID.
      });
    });
  }

  read(path) {
    const { NoSuchFileError } = SystemA;
    const { NoFileSourceError } = SystemA;
    if (this._fileSource) {
      let file = this._fileSource.recall(path);
      return WebkitFileIngester.readBlob(file).then((contents) => {
        if (contents === null) {
          return Promise.reject(new NoSuchFileError(path));
        }
        return Promise.resolve(contents);
      });
    }
    return Promise.reject(new NoFileSourceError);
  }

  write(path, contents) {
    if (path) {
      if (!this._fileName) {
        this._artifacts.store(new Blob([ contents ]), path);
        this._fileName = path;
        return Promise.resolve();
      }
      return Promise.reject(new Error("Can't write multiple files"));
    }
    return Promise.reject(new Error("Empty file name"));
  }

  list(path) {
    return Promise.resolve(
      FileUtils.list(this._fileSource, path)
    );
  }

  // NB: internal use only (for UI; not part of the abstract system interface)
  requestFileSource() {
    this._directoryInput.click();
  }

  _onDirectoryChange($unblock, app, event) {
    let [ file ] = event.target.files;

    this._arg = file.name;

    this._fileSource = new FileCache();
    // XXX WebkitFileIngester.cache([ file ], this._fileSource); // XXX
    this._fileSource.store(file, file.name);

    this._ui.acknowledgeFileSource();
    $unblock(app);
  }

  finish(app, err = null) {
    if (err) {
      throw err; // XXX
    } else if (!this._fileName) {
      throw Error("no file written"); // XXX
    }

    this._export(this._fileName);
  }

  getProgramArguments() {
    return [ this._arg ];
  }

  _export(fileName) {
    this._saveFile(fileName, this._artifacts.recall(fileName));
  }

  _saveFile(name, blob) {
    let anchor = this._document.createElement("a");
    anchor.href = URL.createObjectURL(blob);
    anchor.download = name;
    this._document.head.appendChild(anchor).click();
    anchor.parentNode.removeChild(anchor);
  }
}
